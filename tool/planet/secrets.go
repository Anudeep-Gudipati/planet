package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/gravitational/trace"

	sslconfig "github.com/cloudflare/cfssl/config"
	"github.com/cloudflare/cfssl/csr"
	"github.com/cloudflare/cfssl/initca"
	"github.com/cloudflare/cfssl/signer"
	"github.com/cloudflare/cfssl/signer/universal"
)

// initSecrets takes directory and uses it to generate
// TLS Certificate Authority files and API server certificate/key pair
func initSecrets(hosts []string, dir string) error {
	caConfig, err := initCA(hosts, dir)
	if err != nil {
		return trace.Wrap(err)
	}
	config := &CertConfig{
		CA:    *caConfig,
		CN:    APIServerKeyPair,
		Hosts: hosts,
	}
	if err = generateCert(config, dir, APIServerKeyPair); err != nil {
		return trace.Wrap(err)
	}
	return nil
}

func initCA(hosts []string, dir string) (config *CAConfig, err error) {
	certRequest := csr.CertificateRequest{
		CN: "Gravitational",
		KeyRequest: &csr.BasicKeyRequest{
			A: "rsa",
			S: 2048,
		},
		Hosts: hosts,
		Names: []csr.Name{
			{
				O: "Gravitational",
			},
		},
	}
	cert, _, key, err := initca.New(&certRequest)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	w := &writer{perms: 06444, dir: dir, baseName: CertificateAuthorityKeyPair}
	w.write("cert", string(cert))
	w.write("key", string(key))
	config = &CAConfig{
		certPath: w.filespec("cert"),
		keyPath:  w.filespec("key"),
	}
	return config, trace.Wrap(w.err)
}

func generateCert(config *CertConfig, dir, baseName string) error {
	root := universal.Root{
		Config: map[string]string{
			"cert-file": config.CA.certPath,
			"key-file":  config.CA.keyPath,
		},
	}
	policy := &sslconfig.Signing{
		Default: sslconfig.DefaultConfig(),
	}
	s, err := universal.NewSigner(root, policy)
	if err != nil {
		return trace.Wrap(err)
	}

	certRequest := csr.CertificateRequest{
		CN: config.CN,
		KeyRequest: &csr.BasicKeyRequest{
			A: "rsa",
			S: 2048,
		},
		Hosts: config.Hosts,
		Names: []csr.Name{
			{
				O:  "autogenerated",
				OU: "etcd cluster", // FIXME
			},
		},
	}

	var key, csrBytes []byte
	generator := &csr.Generator{Validator: noopValidator}
	csrBytes, key, err = generator.ProcessRequest(&certRequest)
	if err != nil {
		return trace.Wrap(err)
	}

	var cert []byte
	signRequest := signer.SignRequest{
		Subject: &signer.Subject{
			CN:    config.CN,
			Names: certRequest.Names,
		},
		Request: string(csrBytes),
		Hosts:   config.Hosts,
	}

	cert, err = s.Sign(signRequest)
	if err != nil {
		return trace.Wrap(err)
	}

	w := &writer{perms: 0644, dir: dir, baseName: baseName}
	w.write("cert", string(cert))
	w.write("key", string(key))
	return trace.Wrap(w.err)
}

type CertConfig struct {
	CA    CAConfig
	CN    string
	Hosts []string
}

type CAConfig struct {
	certPath string
	keyPath  string
}

func noopValidator(req *csr.CertificateRequest) error {
	return nil
}

type writer struct {
	dir      string
	baseName string
	perms    os.FileMode
	err      error
}

func (w *writer) write(ext, contents string) {
	if w.err != nil {
		return
	}
	path := w.filespec(ext)
	w.err = trace.Wrap(ioutil.WriteFile(path, []byte(contents), w.perms))
}

func (w *writer) filespec(ext string) string {
	return filepath.Join(w.dir, fmt.Sprintf("%v.%v", w.baseName, ext))
}
