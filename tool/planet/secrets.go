package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/gravitational/trace"

	sslconfig "github.com/cloudflare/cfssl/config"
	"github.com/cloudflare/cfssl/csr"
	"github.com/cloudflare/cfssl/initca"
	"github.com/cloudflare/cfssl/signer"
	"github.com/cloudflare/cfssl/signer/universal"
)

const rootCN = "Gravitational"

// initSecrets takes directory and uses it to generate
// TLS Certificate Authority files and API server certificate/key pair
func initSecrets(hosts []string, dir string) error {
	configCA, err := initCA(hosts, dir)
	if err != nil {
		return trace.Wrap(err)
	}
	config := &certConfig{
		CA:    *configCA,
		CN:    APIServerKeyPair,
		Hosts: hosts,
	}
	if err = generateCert(config, dir, APIServerKeyPair); err != nil {
		return trace.Wrap(err)
	}
	return nil
}

// initCA creates a Certificate Authority key pair, writes the pair into dir
// and returns a configuration object to reference created files.
func initCA(hosts []string, dir string) (configCA *keyPairConfig, err error) {
	certRequest := csr.CertificateRequest{
		CN: rootCN,
		KeyRequest: &csr.BasicKeyRequest{
			A: "rsa",
			S: 2048,
		},
		Hosts: hosts,
		Names: []csr.Name{
			{
				O: rootCN,
			},
		},
	}
	cert, _, key, err := initca.New(&certRequest)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	w := &fileWriter{perms: 0644, dir: dir, baseName: CertificateAuthorityKeyPair}
	w.write("cert", string(cert))
	w.write("key", string(key))
	configCA = &keyPairConfig{
		certPath: w.filespec("cert"),
		keyPath:  w.filespec("key"),
	}
	return configCA, trace.Wrap(w.err)
}

// generateCert generates a certificate/key pair signed by the provided CA
// using the specified config, writes resulting pair into dir using
// baseName as filename.
func generateCert(config *certConfig, dir, baseName string) error {
	root := universal.Root{
		Config: map[string]string{
			"cert-file": config.CA.certPath,
			"key-file":  config.CA.keyPath,
		},
	}
	policy := &sslconfig.Signing{
		Default: sslconfig.DefaultConfig(),
	}
	s, err := universal.NewSigner(root, policy)
	if err != nil {
		return trace.Wrap(err)
	}

	certRequest := csr.CertificateRequest{
		CN: config.CN,
		KeyRequest: &csr.BasicKeyRequest{
			A: "rsa",
			S: 2048,
		},
		Hosts: config.Hosts,
		Names: []csr.Name{
			{
				O:  "autogenerated",
				OU: "planet cluster",
			},
		},
	}

	var key, csrBytes []byte
	generator := &csr.Generator{Validator: noopValidator}
	csrBytes, key, err = generator.ProcessRequest(&certRequest)
	if err != nil {
		return trace.Wrap(err)
	}

	var cert []byte
	signRequest := signer.SignRequest{
		Subject: &signer.Subject{
			CN:    config.CN,
			Names: certRequest.Names,
		},
		Request: string(csrBytes),
		Hosts:   config.Hosts,
	}

	cert, err = s.Sign(signRequest)
	if err != nil {
		return trace.Wrap(err)
	}

	w := &fileWriter{perms: 0644, dir: dir, baseName: baseName}
	w.write("cert", string(cert))
	w.write("key", string(key))
	return trace.Wrap(w.err)
}

// certConfig defines the parameters to generate a TLS certificate/key pair
type certConfig struct {
	CA    keyPairConfig
	CN    string
	Hosts []string
}

// keyPairConfig represents a certificate/key file pair
type keyPairConfig struct {
	certPath string
	keyPath  string
}

func noopValidator(req *csr.CertificateRequest) error {
	return nil
}

// fileWriter defines an interface to write files with the specified
// permissions into the given directory
type fileWriter struct {
	dir      string
	baseName string
	perms    os.FileMode
	err      error
}

func (w *fileWriter) write(ext, contents string) {
	if w.err != nil {
		return
	}
	path := w.filespec(ext)
	w.err = trace.Wrap(ioutil.WriteFile(path, []byte(contents), w.perms))
}

func (w *fileWriter) filespec(ext string) string {
	return filepath.Join(w.dir, fmt.Sprintf("%v.%v", w.baseName, ext))
}
