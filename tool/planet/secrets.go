package main

import (
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/gravitational/trace"

	"github.com/cloudflare/cfssl/config"
	"github.com/cloudflare/cfssl/csr"
	"github.com/cloudflare/cfssl/signer"
	"github.com/cloudflare/cfssl/signer/universal"
)

// initSecrets takes directory and initializes k8s secrets like
// TLS Certificate authority and APIserver certificate in it
func initSecrets(dir, domain string, serviceSubnet CIDR) error {
	if err := os.MkdirAll(dir, 0777); err != nil {
		return trace.Wrap(err)
	}

	// init key pair for certificate authority
	ca, err := initKeyPair(
		dir, domain, CertificateAuthorityKeyPair, serviceSubnet, nil, true)
	if err != nil {
		return trace.Wrap(err)
	}

	// init key pair for apiserver signed by our authority
	_, err = initKeyPair(
		dir, domain, APIServerKeyPair, serviceSubnet, ca.keyPair, false)
	if err != nil {
		return trace.Wrap(err)
	}

	return nil
}

func generateCert(caDir, dir, domain string) error {
	caFile := filepath.Join(caDir, "root.cert")
	caKeyFile := filepath.Join(caDir, "root.key")
	root := universal.Root{
		Config: map[string]string{
			"cert-file": caFile,
			"key-file":  caKeyFile,
		},
	}
	policy := &config.Signing{
		Profiles: map[string]*config.SigningProfile{},
		Default:  config.DefaultConfig(),
	}
	s, err := universal.NewSigner(root, policy)
	if err != nil {
		return trace.Wrap(err)
	}

	certRequest := csr.CertificateRequest{
		CN: "etcd", // FIXME: configure
		KeyRequest: &csr.BasicKeyRequest{
			A: "rsa",
			S: 2048,
		},
		Hosts: []string{domain},
		Names: []csr.Name{
			{
				O:  "autogenerated",
				OU: "etcd cluster",
			},
		},
	}

	var key, csrBytes []byte
	generator := &csr.Generator{Validator: noopValidator}
	csrBytes, key, err = generator.ProcessRequest(&certRequest)
	if err != nil {
		return trace.Wrap(err)
	}

	var cert []byte
	signRequest := signer.SignRequest{
		Request: string(csrBytes),
		Hosts:   signer.SplitHosts(domain),
	}

	cert, err = s.Sign(signRequest)
	if err != nil {
		return trace.Wrap(err)
	}

	w := &writer{perms: 0644, dir: dir}
	w.write("etcd.cert", string(cert))
	w.write("etcd.key", string(key))
	w.write("etcd.csr", string(csrBytes))
	return trace.Wrap(w.err)
}

func noopValidator(req *csr.CertificateRequest) error {
	return nil
}

type writer struct {
	dir   string
	perms os.FileMode
	err   error
}

func (w *writer) write(filespec, contents string) {
	if w.err != nil {
		return
	}
	path := filepath.Join(w.dir, filespec)
	w.err = trace.Wrap(ioutil.WriteFile(path, []byte(contents), w.perms))
}
